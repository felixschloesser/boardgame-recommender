random_seed = 42
logging_level = "INFO"

[paths]
stopwords_file = "data/stopwords.txt"
synonyms_file = "data/synonyms.toml"
raw_data_directory = "data/raw"
processed_features_directory = "data/processed"
embeddings_directory = "data/embeddings"


[preprocessing.filters]
max_year = 2020                 # Exclude very new games lacking enough ratings
min_popularity_quantile = 0.30  # Drop the least popular 30% of games
min_avg_rating = 5.0            # Drop very poorly rated games
popularity_override_min_num_ratings = 10000   # Keep massively popular titles even if low-rated
popularity_override_top_owned_quantile = 0.95 # Keep top 5% most-owned titles even if low-rated
max_required_players = 6        # Drop games that require 6+ players
max_playing_time_minutes = 210  # Drop extremely long games


[preprocessing.features]
text = ["description"]
categorical = ["mechanics", "categories", "themes"]
numeric = ["min_players", "max_players", "complexity", "age_recommendation",
"num_user_ratings", "year_published", "playing_time_minutes"]


[preprocessing.features.weights]
description = 1.0    # What the game is about
mechanics = 0.8      # How the game works
categories = 0.8     # What type of game it is
themes = 0.6         # The setting or story
numeric = 0.7        # Player counts, complexity, etc.

[preprocessing.tokenization]
# Normalize equivalent phrases so descriptions use a consistent vocabulary
# (e.g., "deck builder" → "deckbuilding"; "co-op" → "cooperative")
unify_synonyms = true

# Remove extremely common board-game terms that add no discriminative value
# (e.g., "game", "players", "board", "turn") to emphasize distinctive concepts
remove_common_domain_words = true

# Extract both single words and common two-word expressions
# (e.g., "area control", "worker placement") to capture domain-specific concepts
ngram_range = [1, 2]



[training.text_vectorization]
# Drop terms that appear in fewer than this many game descriptions (removes typos and noise)
min_document_occurrences = 3

# Ignore terms that appear in more than this proportion of descriptions (removes generic filler wording)
max_document_frequency = 0.90

# Prevent long descriptions from overpowering short ones
equalize_description_length = true

# Reduce the influence of repeated words within a single description ("highly, highly tactical")
downweight_repeated_terms = true


[training.embedding_model]
# If true, all embedding vectors are scaled to the same length.
# This means similarity depends only on *which* structural patterns a game has,
# not on how many or how strongly they are expressed.
#
# Leave this off unless you want the system to treat “feature-rich” games
# (dense mechanics, many thematic elements) as not similar to each other.
normalize_embedding_vectors = false

# This controls how detailed the embedding’s representation of
# game-to-game similarity becomes:
#
#   100–200  → broad similarity structure
#              (e.g., party games vs euros vs thematic adventures)
#
#   300–400  → balanced detail
#              (e.g., differentiates engine-building from tableau-building,
#              recognizes distinct co-op subtypes, etc.)
#
#   500–700  → very fine-grained distinctions
#              (captures niche mechanical patterns and rare combinations,
#              useful only if the dataset is large and diverse)
#
# Lower values generalize more strongly; higher values capture more nuance
# but require more data and can emphasize subtle patterns.
embedding_dimensions = 250



[recommendation]
# "max" = strong preferences (if a game matches any of your preferred structures strongly, it scores well)
# "mean" = balanced structure (game must match overall profile)
similarity_aggregation = "max"

[recommendation.preference_cluster]
# Most players like different kinds of games (e.g., heavy strategy, quick fillers,
# thematic co-ops). If we combine all liked games into one profile, these distinct
# structures get averaged together and lose their meaning. Splitting liked games into
# multiple preference clusters keeps each pattern visible, so the system can
# recommend titles that match any of the user's real interests.
min_samples_per_centroid = 3
# Don’t split preference clusters unless user likes enough games to justify it.
dynamic_centroids = true
centroid_scaling_factor = 0.3
# Example: User likes 10 games → 10 * 0.3 = ~3 preference clusters.
